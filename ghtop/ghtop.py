# AUTOGENERATED! DO NOT EDIT! File to edit: 00_ghtop.ipynb (unless otherwise specified).

__all__ = ['term', 'logfile', 'github_auth_device', 'exit', 'get_token', 'limit_cb', 'fetch_events', 'read_json_log',
           'Events', 'printed_event_ids', 'to_log', 'print_event', 'write_logs', 'tail_events', 'watch_users',
           'push_to_log', 'str_clean', 'signal_handler', 'quad_logs', 'simple', 'help_msg', 'mode_map']

# Cell
import time, sys, signal, shutil, os, json, enlighten, emoji, blessed
from .dashing import *
from collections import defaultdict

from fastcore.utils import *
from fastcore.foundation import *
from fastcore.script import *
from ghapi.all import *

# Cell
term = Terminal()
logfile = Path("log.txt")

# Cell
def github_auth_device():
    auth = GhDeviceAuth()
    wb = input(f"""First copy your one-time code: {term.yellow}{auth.user_code}{term.normal}
    Then visit {auth.verification_uri} in your browser, and paste the code when prompted.
    Shall we try to open the link for you? [y/n] """)
    if wb[0].lower()=='y': auth.open_browser()

    print ("Waiting for authorization...", end='')
    token = auth.wait(lambda: print('.', end=''))
    print("Authenticated with GitHub!")
    return token

# Cell
def exit(msg):
    print(msg, file=sys.stderr)
    sys.exit()

# Cell
def get_token():
    path = Path.home()/".ghtop_token"
    if path.is_file():
        try: return path.read_text().strip()
        except: exit("Error reading token")

    token = github_auth_device()
    path.write_text(token)
    return token

# Cell
def limit_cb(rem,quota):
    w='WARNING '*7
    if rem < 1000: print(f"{w}\nRemaining calls: {rem} out of {quota}\n{w}")

# Cell
def fetch_events(): return api.activity.list_public_events(per_page=100)

def _maybeAttrDict(x): return AttrDict(x) if isinstance(x, dict) else x

# Cell
def read_json_log():
    try: res = logfile.read_json()
    except FileNotFoundError: return []
    return L(res).map(dict2obj) if isinstance(res,list) else L([dict2obj(res)])

# Cell
Events = dict(
    IssuesEvent_closed=('⭐', 'closed', noop),
    IssuesEvent_opened=('📫', 'opened', noop),
    IssueCommentEvent=('💬', 'commented on', term.white),
    PullRequestEvent_opened=('✨', 'opened a pull request', term.yellow),
    PullRequestEvent_closed=('✔', 'closed a pull request', term.green),
)

# Cell
printed_event_ids = {}

# Cell
def to_log(e):
    login,repo,pay = e.actor.login,e.repo.name,e.payload
    typ = e.type + (f'_{pay.action}' if e.type in ('PullRequestEvent','IssuesEvent') else '')
    emoji,msg,color = Events.get(typ, [0]*3)
    if emoji:
        xtra = '' if e.type == "PullRequestEvent" else f' issue # {pay.issue.number}'
        d = try_attrs(pay, "pull_request", "issue")
        return color(f'{emoji} {login} {msg}{xtra} on repo {repo[:20]} ("{d.title[:50]}...")')
    elif e.type == "ReleaseEvent": return f'🚀 {login} released {e.payload.release.tag_name} of {repo}'

# Cell
def print_event(e, commits_counter):
    if e.id in printed_event_ids: return
    printed_event_ids[e.id] = 1
    login = e.actor.login
    if "bot" in login or "b0t" in login: return  # Don't print bot activity (there is a lot!)

    res = to_log(e)
    if res: print(res)
    elif e.type == "PushEvent": [commits_counter.update() for c in e.payload.commits]
    elif e.type == "SecurityAdvisoryEvent": print(term.blink("SECURITY ADVISORY"))

# Cell
def write_logs(events):
    Path("tmp.log").write_text(json.dumps(events, indent=2))
    shutil.move("tmp.log", logfile)

def tail_events():
    manager = enlighten.get_manager()
    commits = manager.counter(desc='Commits', unit='commits', color='green')
    while True:
        combined = (fetch_events()+read_json_log()).sorted(using_attr(int,"id"))
        write_logs(obj2dict(combined))
        for x in combined: print_event(x, commits)
        time.sleep(0.2)

# Cell
def watch_users():
    users,users_events = defaultdict(int),defaultdict(lambda: defaultdict(int))
    while True:
        for x in fetch_events():
            login = e.actor.login
            users[login] += 1
            users_events[login][x.type] += 1

        print (term.clear())
        print ("User".ljust(30), "Events".ljust(6), "PRs".ljust(5), "Issues".ljust(6), "Pushes".ljust(7))
        sorted_users = sorted(users.items(), key = lambda kv: (kv[1], kv[0]), reverse=True)
        for i in range(20):
            u = sorted_users[i]
            ue = users_events[u[0]]
            print(u[0].ljust(30), str(u[1]).ljust(6),
                  str(ue.get('PullRequestEvent', '')).ljust(5),
                  str(ue.get('IssuesEvent', '')).ljust(6),
                  str(ue.get('PushEvent', '')).ljust(7))
        time.sleep(1)

# Cell
def push_to_log(e):
    return f"{e.actor.login} pushed {len(e.payload.commits)} commits to repo {e.repo.name}"

# Cell
def str_clean(s): return s[:95]

# Cell
def signal_handler(sig, frame):
    if sig != signal.SIGINT: return
    print(term.exit_fullscreen())
    print(term.clear())
    print(term.normal)
    sys.exit(0)

# Cell
def quad_logs():
    term.enter_fullscreen()
    ui = HSplit(
            VSplit(
                Log(title='Issues', border_color = 2, color=7),
                Log(title='Commits', border_color = 2, color=3)
            ),
            VSplit(
                Log(title='Pull Requests', border_color = 2, color=4),
                Log(title='Releases', border_color = 2, color=5)
            ),
        )

    issues,commits = ui.items[0].items
    prs,releases = ui.items[1].items
    for o in issues,commits,prs,releases: o.append(" ")

    while True:
        for x in fetch_events():
            t = x["type"]
            if t == 'PushEvent': commits.append(str_clean(push_to_log(x)))
            elif t == 'IssuesEvent' or t == 'IssueCommentEvent': issues.append(str_clean(to_log(x)))
            elif t == 'PullRequestEvent': prs.append(str_clean(to_log(x)))
            elif t == 'ReleaseEvent': releases.append(str_clean(to_log(x)))
        ui.display()
        time.sleep(0.1)

# Cell
def simple():
    while True:
        for x in fetch_events(): print(f"{x.actor.login} {x.type} {x.repo.name}")

# Cell
help_msg = "Usage: ghtop <tail|quad|users|simple>"
mode_map = defaultdict(lambda: exit(help_msg),{'tail': tail_events,
                                              'quad': quad_logs,
                                              'users': watch_users,
                                              'simple': simple})

if __name__ == '__main__' and not in_jupyter():
    if len(sys.argv) < 2: exit(help_msg)
    _, mode, *_ = sys.argv
    signal.signal(signal.SIGINT, signal_handler)
    mode_map[mode]()